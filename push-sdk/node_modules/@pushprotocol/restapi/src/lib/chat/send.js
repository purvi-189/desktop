"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.send = void 0;
const tslib_1 = require("tslib");
const axios_1 = require("axios");
const helpers_1 = require("../helpers");
const constants_1 = require("../constants");
const helpers_2 = require("./helpers");
const conversationHash_1 = require("./conversationHash");
const start_1 = require("./start");
const helpers_3 = require("./helpers");
/**
 * Send a message to an address or a group
 */
const send = (options) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { messageContent = '', messageType = 'Text', receiverAddress, account = null, signer = null, pgpPrivateKey = null, apiKey = '', env = constants_1.default.ENV.PROD, } = options || {};
    try {
        if (account == null && signer == null) {
            throw new Error(`At least one from account or signer is necessary!`);
        }
        const wallet = (0, helpers_2.getWallet)({ account, signer });
        const address = yield (0, helpers_2.getAccountAddress)(wallet);
        if (!(0, helpers_1.isValidETHAddress)(address)) {
            throw new Error(`Invalid address!`);
        }
        let isGroup = false;
        if (!(0, helpers_1.isValidETHAddress)(receiverAddress)) {
            isGroup = true;
        }
        const connectedUser = yield (0, helpers_2.getConnectedUserV2)(wallet, pgpPrivateKey, env);
        const receiver = yield (0, helpers_2.getUserDID)(receiverAddress, env);
        let conversationResponse = null;
        if (!isGroup) {
            conversationResponse = yield (0, conversationHash_1.conversationHash)({
                conversationId: receiver,
                account: connectedUser.did,
                env,
            });
        }
        if (conversationResponse && !(conversationResponse === null || conversationResponse === void 0 ? void 0 : conversationResponse.threadHash)) {
            return (0, start_1.start)({
                messageContent: messageContent,
                messageType: messageType,
                receiverAddress: receiver,
                connectedUser,
                apiKey,
                env,
            });
        }
        else {
            const API_BASE_URL = (0, helpers_1.getAPIBaseUrls)(env);
            const apiEndpoint = `${API_BASE_URL}/v1/chat/message`;
            const body = yield (0, helpers_3.sendMessagePayload)(receiver, connectedUser, messageContent, messageType, env);
            return axios_1.default
                .post(apiEndpoint, body)
                .then((response) => {
                return response.data;
            })
                .catch((err) => {
                throw new Error(err);
            });
        }
    }
    catch (err) {
        console.error(`[Push SDK] - API  - Error - API ${exports.send.name} -:  `, err);
        throw Error(`[Push SDK] - API  - Error - API ${exports.send.name} -: ${err}`);
    }
});
exports.send = send;
//# sourceMappingURL=send.js.map