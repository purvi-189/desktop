"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDecryptedPrivateKey = exports.getEip712Signature = exports.getEip191Signature = exports.getEncryptedRequest = exports.decryptMessages = exports.decryptFeeds = exports.signMessageWithPGP = exports.encryptAndSign = void 0;
const tslib_1 = require("tslib");
const PGP = require("./pgp");
const AES = require("./aes");
const user_1 = require("../../user");
const helpers_1 = require("../../helpers");
const user_2 = require("../../user");
const service_1 = require("./service");
const constants_1 = require("../../constants");
const signature_1 = require("./signature");
const SIG_TYPE_V2 = 'eip712v2';
const encryptAndSign = ({ plainText, keys, privateKeyArmored, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const secretKey = AES.generateRandomSecret(15);
    const cipherText = AES.aesEncrypt({ plainText, secretKey });
    const encryptedSecret = yield PGP.pgpEncrypt({
        plainText: secretKey,
        keys: keys,
    });
    const signature = yield PGP.sign({
        message: cipherText,
        signingKey: privateKeyArmored,
    });
    return {
        cipherText,
        encryptedSecret,
        signature,
        sigType: 'pgp',
        encType: 'pgp',
    };
});
exports.encryptAndSign = encryptAndSign;
const signMessageWithPGP = ({ message, privateKeyArmored, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const signature = yield PGP.sign({
        message: message,
        signingKey: privateKeyArmored,
    });
    return {
        signature,
        sigType: 'pgp',
    };
});
exports.signMessageWithPGP = signMessageWithPGP;
const decryptFeeds = ({ feeds, connectedUser, pgpPrivateKey, env = constants_1.default.ENV.PROD, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    let otherPeer;
    let signatureValidationPubliKey; // To do signature verification it depends on who has sent the message
    for (const feed of feeds) {
        let gotOtherPeer = false;
        if (feed.msg.encType !== 'PlainText') {
            if (!pgpPrivateKey) {
                throw Error('Decrypted private key is necessary');
            }
            if (feed.msg.fromCAIP10 !== connectedUser.wallets.split(',')[0]) {
                if (!gotOtherPeer) {
                    otherPeer = yield (0, user_2.get)({ account: feed.msg.fromCAIP10, env });
                    gotOtherPeer = true;
                }
                signatureValidationPubliKey = otherPeer.publicKey;
            }
            else {
                signatureValidationPubliKey = connectedUser.publicKey;
            }
            feed.msg.messageContent = yield (0, helpers_1.decryptAndVerifySignature)({
                cipherText: feed.msg.messageContent,
                encryptedSecretKey: feed.msg.encryptedSecret,
                publicKeyArmored: signatureValidationPubliKey,
                signatureArmored: feed.msg.signature,
                privateKeyArmored: pgpPrivateKey,
                message: feed.msg,
            });
        }
    }
    return feeds;
});
exports.decryptFeeds = decryptFeeds;
const decryptMessages = ({ savedMsg, connectedUser, account, currentChat, inbox, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (connectedUser.privateKey) {
        if (savedMsg.encType !== 'PlainText' && savedMsg.encType !== null) {
            // To do signature verification it depends on who has sent the message
            let signatureValidationPubliKey = '';
            if (savedMsg.fromCAIP10 === (0, helpers_1.walletToPCAIP10)(account)) {
                signatureValidationPubliKey = connectedUser.publicKey;
            }
            else {
                if (!currentChat.publicKey) {
                    const latestUserInfo = inbox.find((x) => x.wallets.split(',')[0] === currentChat.wallets.split(',')[0]);
                    if (latestUserInfo) {
                        signatureValidationPubliKey = latestUserInfo.publicKey;
                    }
                }
                else {
                    signatureValidationPubliKey = currentChat.publicKey;
                }
            }
            savedMsg.messageContent = yield (0, helpers_1.decryptAndVerifySignature)({
                cipherText: savedMsg.messageContent,
                encryptedSecretKey: savedMsg.encryptedSecret,
                privateKeyArmored: connectedUser.privateKey,
                publicKeyArmored: signatureValidationPubliKey,
                signatureArmored: savedMsg.signature,
                message: savedMsg,
            });
        }
    }
    return savedMsg;
});
exports.decryptMessages = decryptMessages;
const getEncryptedRequest = (receiverAddress, senderCreatedUser, message, isGroup, env, group) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!isGroup) {
        const receiverCreatedUser = yield (0, user_1.get)({
            account: receiverAddress,
            env,
        });
        if (!(receiverCreatedUser === null || receiverCreatedUser === void 0 ? void 0 : receiverCreatedUser.publicKey)) {
            if (!(0, helpers_1.isValidETHAddress)(receiverAddress)) {
                throw new Error(`Invalid receiver address!`);
            }
            yield (0, service_1.createUserService)({
                user: receiverAddress,
                publicKey: '',
                encryptedPrivateKey: '',
                env,
            });
            // If the user is being created here, that means that user don't have a PGP keys. So this intent will be in plaintext
            const { signature } = yield (0, exports.signMessageWithPGP)({
                message: message,
                privateKeyArmored: senderCreatedUser.privateKey,
            });
            return {
                message: message,
                encryptionType: 'PlainText',
                aesEncryptedSecret: '',
                signature: signature,
            };
        }
        else {
            // It's possible for a user to be created but the PGP keys still not created
            if (!receiverCreatedUser.publicKey.includes('-----BEGIN PGP PUBLIC KEY BLOCK-----')) {
                const { signature } = yield (0, exports.signMessageWithPGP)({
                    message: message,
                    privateKeyArmored: senderCreatedUser.privateKey,
                });
                return {
                    message: message,
                    encryptionType: 'PlainText',
                    aesEncryptedSecret: '',
                    signature: signature,
                };
            }
            else {
                const { cipherText, encryptedSecret, signature } = yield (0, exports.encryptAndSign)({
                    plainText: message,
                    keys: [receiverCreatedUser.publicKey, senderCreatedUser.publicKey],
                    privateKeyArmored: senderCreatedUser.privateKey,
                });
                return {
                    message: cipherText,
                    encryptionType: 'pgp',
                    aesEncryptedSecret: encryptedSecret,
                    signature: signature,
                };
            }
        }
    }
    else if (group) {
        if (group.isPublic) {
            const { signature } = yield (0, exports.signMessageWithPGP)({
                message: message,
                privateKeyArmored: senderCreatedUser.privateKey,
            });
            return {
                message: message,
                encryptionType: 'PlainText',
                aesEncryptedSecret: '',
                signature: signature,
            };
        }
        else {
            const publicKeys = group.members.map((member) => member.publicKey);
            const { cipherText, encryptedSecret, signature } = yield (0, exports.encryptAndSign)({
                plainText: message,
                keys: publicKeys,
                privateKeyArmored: senderCreatedUser.privateKey,
            });
            return {
                message: cipherText,
                encryptionType: 'pgp',
                aesEncryptedSecret: encryptedSecret,
                signature: signature,
            };
        }
    }
});
exports.getEncryptedRequest = getEncryptedRequest;
const getEip191Signature = (wallet, message, version = 'v1') => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
        console.warn('This method is deprecated. Provide signer in the function');
        // sending random signature for making it backward compatible
        return { signature: 'xyz', sigType: 'a' };
    }
    const _signer = wallet === null || wallet === void 0 ? void 0 : wallet.signer;
    // EIP191 signature
    const signature = yield (_signer === null || _signer === void 0 ? void 0 : _signer.signMessage(message));
    const sigType = version === 'v1' ? 'eip191' : 'eip191v2';
    return { verificationProof: `${sigType}:${signature}` };
});
exports.getEip191Signature = getEip191Signature;
const getEip712Signature = (wallet, hash, isDomainEmpty) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    if (!(wallet === null || wallet === void 0 ? void 0 : wallet.signer)) {
        console.warn('This method is deprecated. Provide signer in the function');
        // sending random signature for making it backward compatible
        return { signature: 'xyz', sigType: 'a' };
    }
    const typeInformation = (0, signature_1.getTypeInformation)();
    const _signer = wallet === null || wallet === void 0 ? void 0 : wallet.signer;
    let chainId;
    try {
        chainId = yield _signer.getChainId();
    }
    catch (err) {
        chainId = 1;
    }
    const domain = (0, signature_1.getDomainInformation)(chainId);
    // sign a message using EIP712
    const signedMessage = yield (_signer === null || _signer === void 0 ? void 0 : _signer._signTypedData(isDomainEmpty ? {} : domain, typeInformation, { data: hash }));
    const verificationProof = isDomainEmpty
        ? `${SIG_TYPE_V2}:${signedMessage}`
        : `${SIG_TYPE_V2}:${chainId}:${signedMessage}`;
    return { verificationProof };
});
exports.getEip712Signature = getEip712Signature;
function getDecryptedPrivateKey(wallet, user, address) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let decryptedPrivateKey;
        if (wallet.signer) {
            decryptedPrivateKey = yield (0, helpers_1.decryptPGPKey)({
                signer: wallet.signer,
                encryptedPGPPrivateKey: user.encryptedPrivateKey,
            });
        }
        else {
            decryptedPrivateKey = yield (0, helpers_1.decryptWithWalletRPCMethod)(user.encryptedPrivateKey, address);
        }
        return decryptedPrivateKey;
    });
}
exports.getDecryptedPrivateKey = getDecryptedPrivateKey;
//# sourceMappingURL=crypto.js.map