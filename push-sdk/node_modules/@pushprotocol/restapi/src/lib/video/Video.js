"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Video = exports.initVideoCallData = void 0;
const tslib_1 = require("tslib");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const Peer = require("simple-peer");
const immer_1 = require("immer");
const constants_1 = require("../constants");
const sendVideoCallNotification_1 = require("./helpers/sendVideoCallNotification");
const mediaToggle_1 = require("./helpers/mediaToggle");
const isJSON_1 = require("./helpers/isJSON");
const types_1 = require("../types");
exports.initVideoCallData = {
    meta: {
        chatId: '',
        initiator: {
            address: '',
            signal: null,
        },
    },
    local: {
        stream: null,
        audio: null,
        video: null,
        address: '',
    },
    incoming: [
        {
            stream: null,
            audio: null,
            video: null,
            address: '',
            status: types_1.VideoCallStatus.UNINITIALIZED,
            retryCount: 0,
        },
    ],
};
class Video {
    constructor({ signer, chainId, pgpPrivateKey, env, setData, }) {
        // storing the peer instance
        this.peerInstance = null;
        this.signer = signer;
        this.chainId = chainId;
        this.pgpPrivateKey = pgpPrivateKey;
        this.env = env ? env : constants_1.default.ENV.PROD;
        // init the react state
        setData(() => exports.initVideoCallData);
        // init the class variable
        this.data = exports.initVideoCallData;
        // set the state updating function
        this.setData = function (fn) {
            // update the react state
            setData(fn);
            // update the class variable
            this.data = fn(this.data);
        };
    }
    create(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { audio = true, video = true, stream = null } = options || {};
            try {
                const localStream = stream !== null
                    ? stream // for backend
                    : yield navigator.mediaDevices.getUserMedia({
                        // for frontend
                        video,
                        audio,
                    });
                this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                        draft.local.stream = localStream;
                        draft.local.video = video;
                        draft.local.audio = audio;
                    });
                });
            }
            catch (err) {
                console.log('error in create', err);
            }
        });
    }
    request(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { senderAddress, // notification sender
            recipientAddress, // notification receiver
            chatId, onReceiveMessage = (message) => {
                console.log('received a meesage', message);
            }, retry = false, } = options || {};
            try {
                console.log('request', 'options', options, 'localStream', this.data.local.stream);
                this.peerInstance = new Peer({
                    initiator: true,
                    trickle: false,
                    stream: this.data.local.stream,
                });
                this.peerInstance.on('signal', (data) => {
                    this.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                            draft.meta.initiator.signal = data;
                        });
                    });
                    // sending notification to the recipientAddress with video call signaling data
                    (0, sendVideoCallNotification_1.default)({
                        signer: this.signer,
                        chainId: this.chainId,
                        pgpPrivateKey: this.pgpPrivateKey,
                    }, {
                        senderAddress,
                        recipientAddress,
                        status: retry
                            ? types_1.VideoCallStatus.RETRY_INITIALIZED
                            : types_1.VideoCallStatus.INITIALIZED,
                        chatId,
                        signalData: data,
                        env: this.env,
                    });
                });
                this.peerInstance.on('connect', () => {
                    this.peerInstance.send(`initial message from ${senderAddress}`);
                    this.peerInstance.send(JSON.stringify({
                        type: 'isVideoOn',
                        isVideoOn: this.data.local.video,
                    }));
                    this.peerInstance.send(JSON.stringify({
                        type: 'isAudioOn',
                        isAudioOn: this.data.local.audio,
                    }));
                });
                this.peerInstance.on('data', (data) => {
                    if ((0, isJSON_1.default)(data)) {
                        const parsedData = JSON.parse(data);
                        if (parsedData.type === 'isVideoOn') {
                            console.log('IS VIDEO ON', parsedData.isVideoOn);
                            this.setData((oldData) => {
                                return (0, immer_1.produce)(oldData, (draft) => {
                                    draft.incoming[0].video = parsedData.isVideoOn;
                                });
                            });
                        }
                        if (parsedData.type === 'isAudioOn') {
                            console.log('IS AUDIO ON', parsedData.isAudioOn);
                            this.setData((oldData) => {
                                return (0, immer_1.produce)(oldData, (draft) => {
                                    draft.incoming[0].audio = parsedData.isAudioOn;
                                });
                            });
                        }
                        if (parsedData.type === 'endCall') {
                            console.log('END CALL', parsedData.endCall);
                            // destroy the local stream
                            if (this.data.local.stream) {
                                (0, mediaToggle_1.endStream)(this.data.local.stream);
                            }
                            // reset the state
                            this.setData(() => exports.initVideoCallData);
                        }
                    }
                    else {
                        onReceiveMessage(data);
                    }
                });
                this.peerInstance.on('stream', (currentStream) => {
                    console.log('received incoming stream', currentStream);
                    this.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                            draft.incoming[0].stream = currentStream;
                        });
                    });
                });
                // set videoCallInfo state with status 1 (call initiated)
                this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                        draft.local.address = senderAddress;
                        draft.incoming[0].address = recipientAddress;
                        draft.meta.chatId = chatId;
                        draft.meta.initiator.address = senderAddress;
                        draft.incoming[0].status = retry
                            ? types_1.VideoCallStatus.RETRY_INITIALIZED
                            : types_1.VideoCallStatus.INITIALIZED;
                        draft.incoming[0].retryCount += retry ? 1 : 0;
                    });
                });
            }
            catch (err) {
                console.log('error in request', err);
            }
        });
    }
    acceptRequest(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { signalData, senderAddress, // notification sender
            recipientAddress, // notification receiver
            chatId, onReceiveMessage = (message) => {
                console.log('received a meesage', message);
            }, retry = false, } = options || {};
            try {
                console.log('accept request', 'options', options, 'localStream', this.data.local.stream);
                // if peerInstance is not null -> acceptRequest/request was called before
                if (this.peerInstance !== null) {
                    // to prevent connection error we stop the exec of acceptRequest
                    return Promise.resolve();
                }
                this.peerInstance = new Peer({
                    initiator: false,
                    trickle: false,
                    stream: this.data.local.stream,
                });
                this.peerInstance.signal(signalData);
                this.peerInstance.on('signal', (data) => {
                    this.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                            draft.meta.initiator.signal = data;
                        });
                    });
                    (0, sendVideoCallNotification_1.default)({
                        signer: this.signer,
                        chainId: this.chainId,
                        pgpPrivateKey: this.pgpPrivateKey,
                    }, {
                        senderAddress,
                        recipientAddress,
                        status: retry
                            ? types_1.VideoCallStatus.RETRY_RECEIVED
                            : types_1.VideoCallStatus.RECEIVED,
                        chatId,
                        signalData: data,
                        env: this.env,
                    });
                });
                this.peerInstance.on('connect', () => {
                    this.peerInstance.send('initial message from receiver');
                    this.peerInstance.send(JSON.stringify({
                        type: 'isVideoOn',
                        isVideoOn: this.data.local.video,
                    }));
                    this.peerInstance.send(JSON.stringify({
                        type: 'isAudioOn',
                        isAudioOn: this.data.local.audio,
                    }));
                    // set videoCallInfo state with status connected for the receiver's end
                    this.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                            draft.incoming[0].status = types_1.VideoCallStatus.CONNECTED;
                        });
                    });
                });
                this.peerInstance.on('data', (data) => {
                    if ((0, isJSON_1.default)(data)) {
                        const parsedData = JSON.parse(data);
                        if (parsedData.type === 'isVideoOn') {
                            console.log('IS VIDEO ON', parsedData.isVideoOn);
                            this.setData((oldData) => {
                                return (0, immer_1.produce)(oldData, (draft) => {
                                    draft.incoming[0].video = parsedData.isVideoOn;
                                });
                            });
                        }
                        if (parsedData.type === 'isAudioOn') {
                            console.log('IS AUDIO ON', parsedData.isAudioOn);
                            this.setData((oldData) => {
                                return (0, immer_1.produce)(oldData, (draft) => {
                                    draft.incoming[0].audio = parsedData.isAudioOn;
                                });
                            });
                        }
                        if (parsedData.type === 'endCall') {
                            console.log('END CALL', parsedData.endCall);
                            // destroy the local stream
                            if (this.data.local.stream) {
                                (0, mediaToggle_1.endStream)(this.data.local.stream);
                            }
                            // reset the state
                            this.setData(() => exports.initVideoCallData);
                        }
                    }
                    else {
                        onReceiveMessage(data);
                    }
                });
                this.peerInstance.on('stream', (currentStream) => {
                    console.log('received incoming stream', currentStream);
                    this.setData((oldData) => {
                        return (0, immer_1.produce)(oldData, (draft) => {
                            draft.incoming[0].stream = currentStream;
                        });
                    });
                });
                // set videoCallInfo state with status 2 (call received)
                this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                        draft.local.address = senderAddress;
                        draft.incoming[0].address = recipientAddress;
                        draft.meta.chatId = chatId;
                        draft.meta.initiator.address = senderAddress;
                        draft.incoming[0].status = retry
                            ? types_1.VideoCallStatus.RETRY_RECEIVED
                            : types_1.VideoCallStatus.RECEIVED;
                        draft.incoming[0].retryCount += retry ? 1 : 0;
                    });
                });
            }
            catch (err) {
                console.log('error in accept request', err);
                if (this.data.incoming[0].retryCount >= 5) {
                    console.log('Max retries exceeded, please try again.');
                    this.disconnect();
                }
                // retrying in case of connection error
                (0, sendVideoCallNotification_1.default)({
                    signer: this.signer,
                    chainId: this.chainId,
                    pgpPrivateKey: this.pgpPrivateKey,
                }, {
                    senderAddress,
                    recipientAddress,
                    status: types_1.VideoCallStatus.RETRY_INITIALIZED,
                    chatId,
                    signalData: null,
                    env: this.env,
                });
            }
        });
    }
    connect(options) {
        var _a;
        const { signalData } = options || {};
        try {
            console.log('connect', 'options', options);
            (_a = this.peerInstance) === null || _a === void 0 ? void 0 : _a.signal(signalData);
            // set videoCallInfo state with status connected for the caller's end
            this.setData((oldData) => {
                return (0, immer_1.produce)(oldData, (draft) => {
                    draft.incoming[0].status = types_1.VideoCallStatus.CONNECTED;
                });
            });
        }
        catch (err) {
            console.log('error in connect', err);
            if (this.data.incoming[0].retryCount >= 5) {
                console.log('Max retries exceeded, please try again.');
                this.disconnect();
            }
            // retrying in case of connection error
            this.request({
                senderAddress: this.data.local.address,
                recipientAddress: this.data.incoming[0].address,
                chatId: this.data.meta.chatId,
                retry: true,
            });
        }
    }
    disconnect() {
        var _a, _b;
        try {
            console.log('disconnect', 'status', this.data.incoming[0].status);
            if (this.data.incoming[0].status === types_1.VideoCallStatus.CONNECTED) {
                (_a = this.peerInstance) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({ type: 'endCall', endCall: true }));
                (_b = this.peerInstance) === null || _b === void 0 ? void 0 : _b.destroy();
            }
            else {
                // for disconnecting during status INITIALIZED, RECEIVED, RETRY_INITIALIZED, RETRY_RECEIVED
                // send a notif to the other user signaling status = DISCONNECTED
                (0, sendVideoCallNotification_1.default)({
                    signer: this.signer,
                    chainId: this.chainId,
                    pgpPrivateKey: this.pgpPrivateKey,
                }, {
                    senderAddress: this.data.local.address,
                    recipientAddress: this.data.incoming[0].address,
                    status: types_1.VideoCallStatus.DISCONNECTED,
                    chatId: this.data.meta.chatId,
                    signalData: null,
                    env: this.env,
                });
            }
            // destroy the peerInstance
            this.peerInstance = null;
            // destroy the local stream
            if (this.data.local.stream) {
                (0, mediaToggle_1.endStream)(this.data.local.stream);
            }
            // reset the state
            this.setData(() => exports.initVideoCallData);
        }
        catch (err) {
            console.log('error in disconnect', err);
        }
    }
    // functions for enabling/disabling local audio and video
    enableVideo(options) {
        var _a;
        const { state } = options || {};
        console.log('enableVideo', 'current video', this.data.local.video, 'requested state', state);
        if (this.data.local.video !== state) {
            // need to change the video state
            if (this.data.incoming[0].status === types_1.VideoCallStatus.CONNECTED) {
                (_a = this.peerInstance) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({
                    type: 'isVideoOn',
                    isVideoOn: state,
                }));
            }
            if (this.data.local.stream) {
                if (state) {
                    (0, mediaToggle_1.restartVideoStream)(this.data.local.stream);
                }
                else {
                    (0, mediaToggle_1.stopVideoStream)(this.data.local.stream);
                }
                this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                        draft.local.video = state;
                    });
                });
            }
        }
    }
    enableAudio(options) {
        var _a;
        const { state } = options || {};
        console.log('enableAudio', 'current audio', this.data.local.audio, 'requested state', state);
        if (this.data.local.audio !== state) {
            // need to change the audio state
            if (this.data.incoming[0].status === types_1.VideoCallStatus.CONNECTED) {
                (_a = this.peerInstance) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({ type: 'isAudioOn', isAudioOn: state }));
            }
            if (this.data.local.stream) {
                if (state) {
                    (0, mediaToggle_1.restartAudioStream)(this.data.local.stream);
                }
                else {
                    (0, mediaToggle_1.stopAudioStream)(this.data.local.stream);
                }
                this.setData((oldData) => {
                    return (0, immer_1.produce)(oldData, (draft) => {
                        draft.local.audio = state;
                    });
                });
            }
        }
    }
    // helper functions
    isInitiator() {
        if (this.data.meta.initiator.address === '' ||
            this.data.local.address === '')
            return false;
        return this.data.meta.initiator.address === this.data.local.address;
    }
}
exports.Video = Video;
//# sourceMappingURL=Video.js.map